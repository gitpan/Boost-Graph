<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Boost::Graph - Perl interface to the Boost-Graph C++ libraries.</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#abstract">ABSTRACT</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#methods">Methods</a></li>
	<ul>

		<ul>

			<li><a href="#new_[constructor]">new [Constructor]</a></li>
			<li><a href="#add_edge()"><code>add_edge()</code></a></li>
			<li><a href="#add_node($node)"><code>add_node($node)</code></a></li>
			<li><a href="#get_edges()"><code>get_edges()</code></a></li>
			<li><a href="#get_nodes()"><code>get_nodes()</code></a></li>
			<li><a href="#has_edge($node1,$node2)"><code>has_edge($node1,$node2)</code></a></li>
			<li><a href="#has_node($node)"><code>has_node($node)</code></a></li>
			<li><a href="#nodecount()"><code>nodecount()</code></a></li>
			<li><a href="#edgecount()"><code>edgecount()</code></a></li>
			<li><a href="#neighbors($node)"><code>neighbors($node)</code></a></li>
			<li><a href="#children_of_directed($node)"><code>children_of_directed($node)</code></a></li>
			<li><a href="#parents_of_directed($node)"><code>parents_of_directed($node)</code></a></li>
		</ul>

	</ul>

	<li><a href="#graph_algorithms">Graph Algorithms</a></li>
	<ul>

		<ul>

			<li><a href="#breadth_first_search($start_node)"><code>breadth_first_search($start_node)</code></a></li>
			<li><a href="#depth_first_search($start_node)"><code>depth_first_search($start_node)</code></a></li>
			<li><a href="#dijkstra_shortest_path($start_node,$end_node)"><code>dijkstra_shortest_path($start_node,$end_node)</code></a></li>
			<li><a href="#all_pairs_shortest_paths_johnson($start_node,$end_node)"><code>all_pairs_shortest_paths_johnson($start_node,$end_node)</code></a></li>
			<li><a href="#transitive_links($nodes)"><code>transitive_links($nodes)</code></a></li>
		</ul>

		<li><a href="#export">EXPORT</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Boost::Graph - Perl interface to the Boost-Graph C++ libraries.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Boost::Graph;
  # Create an empty instance of a Graph
  my $graph = new Boost::Graph(directed=&gt;0, net_name=&gt;'Graph Name', net_id=&gt;1000)</pre>
<pre>
  # add edges
  $graph-&gt;add_edge(node1=&gt;'a', node2=&gt;'b', weight=&gt;1.1, edge=&gt;'edge name');
  $graph-&gt;add_edge(node1=&gt;$node1, node2=&gt;$node2, weight=&gt;2.3, edge=&gt;$edge_obj);</pre>
<pre>
  # algorithms
  my $nodes = $graph-&gt;</pre>
<p>
</p>
<hr />
<h1><a name="abstract">ABSTRACT</a></h1>
<pre>
  Boost::Graph is a perl interface to the Boost-Graph C++ libraries that offer
  many efficient and peer reviewed algorithms.</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Boost::Graph is a perl interface to the Boost-Graph C++ libraries that offer
many efficient and peer reviewed algorithms.</p>
<p>
</p>
<hr />
<h1><a name="methods">Methods</a></h1>
<p>
</p>
<h3><a name="new_[constructor]">new [Constructor]</a></h3>
<p>To add edges and nodes to a graph, you must first instantiate the class using this method.</p>
<pre>
  Input Parameters [Optional]:
  - directed: set to 1 for a directed graph (edges with source and sink nodes)
  - net_name: a name for the graph
  - net_id: an id stored in the object for the graph</pre>
<pre>
  Returns:
  An empty instance of the Boost::Graph object</pre>
<pre>
  Usage: 
  my $graph = new Boost::Graph();
  my $graph = new Boost::Graph(directed=&gt;0, net_name=&gt;'Graph Name', net_id=&gt;1000);</pre>
<p>
</p>
<h3><a name="add_edge()"><code>add_edge()</code></a></h3>
<p>The method adds the given nodes and the edge between them to the graph. In and
undirected graph, the order of the nodes does not matter. In a directed graph, node1
is the source and node2 is the sink. The edge parameter can be used to store an object along
with the pairing. The weight parameter can give a numeric value to the edge (default 1.0).</p>
<pre>
  Input Parameters:
  - node1: the source node
  - node2: the sink node
  - weight: the weight value for the edge (a number) [optional]
  - edge: an scalar or object to be associated with the edge [optional]</pre>
<pre>
  Returns:
  1 if the edge is new, 0 if edge exists already.</pre>
<pre>
  Usage: 
  $graph-&gt;add_edge(node1=&gt;$node1, node2=&gt;$node2, weight=&gt;$weight, edge=&gt;$edge);</pre>
<p>
</p>
<h3><a name="add_node($node)"><code>add_node($node)</code></a></h3>
<p>Adds the node to the network (only needed for disjoint nodes). Returns 1 if node is new, 0 if node exists already.</p>
<p>
</p>
<h3><a name="get_edges()"><code>get_edges()</code></a></h3>
<p>Returns a reference to a list of edges that are 3 part lists: [node1, node2, edge_object].</p>
<p>
</p>
<h3><a name="get_nodes()"><code>get_nodes()</code></a></h3>
<p>Returns a reference to a list of all the nodes.</p>
<p>
</p>
<h3><a name="has_edge($node1,$node2)"><code>has_edge($node1,$node2)</code></a></h3>
<p>Returns 1 if the given edge is in the graph.</p>
<p>
</p>
<h3><a name="has_node($node)"><code>has_node($node)</code></a></h3>
<p>Returns 1 if the passed node is in the network (checks for identical object makeup).</p>
<p>
</p>
<h3><a name="nodecount()"><code>nodecount()</code></a></h3>
<p>Returns the number of nodes in the graph.</p>
<p>
</p>
<h3><a name="edgecount()"><code>edgecount()</code></a></h3>
<p>Returns the number of edges in the graph.</p>
<p>
</p>
<h3><a name="neighbors($node)"><code>neighbors($node)</code></a></h3>
<p>Returns the nodes that are neighbors of this node.</p>
<p>
</p>
<h3><a name="children_of_directed($node)"><code>children_of_directed($node)</code></a></h3>
<p>Returns a listref of the nodes that are children of the input node. For Directed graphs only.</p>
<p>
</p>
<h3><a name="parents_of_directed($node)"><code>parents_of_directed($node)</code></a></h3>
<p>Returns a listref of the nodes that are parents of the input node. For Directed graphs only.</p>
<p>
</p>
<hr />
<h1><a name="graph_algorithms">Graph Algorithms</a></h1>
<p>
</p>
<h3><a name="breadth_first_search($start_node)"><code>breadth_first_search($start_node)</code></a></h3>
<p>Receives the start node and returns a listref of nodes from a breadth first traversal of the graph.</p>
<p>
</p>
<h3><a name="depth_first_search($start_node)"><code>depth_first_search($start_node)</code></a></h3>
<p>Receives the start node and returns a listref of nodes from a depth first traversal of the graph.</p>
<p>
</p>
<h3><a name="dijkstra_shortest_path($start_node,$end_node)"><code>dijkstra_shortest_path($start_node,$end_node)</code></a></h3>
<p>Dijkstra's Shortest Path algorithm finds the shortest weighted-path between the start and end nodes.</p>
<p>Returns a hashref with keys:</p>
<pre>
  - path: path is a listref of the nodes in the path
  - weight: weight is a scalar giving the total weight of the path</pre>
<p>
</p>
<h3><a name="all_pairs_shortest_paths_johnson($start_node,$end_node)"><code>all_pairs_shortest_paths_johnson($start_node,$end_node)</code></a></h3>
<p>The first time this method is called, the shortest path between each pair of nodes in the graph is computed. 
The total weight of the path between the start and end node is returned. Unless the graph is altered, the original
matrix does not need to be re-computed.</p>
<p>
</p>
<h3><a name="transitive_links($nodes)"><code>transitive_links($nodes)</code></a></h3>
<p>Receives a listref of nodes and returns a listref of nodes that are (disjoint 
from the input set) transitive connectors of the input set in the current network.
The transitive distance is limited to one node. (i.e. given a and c as input, and 
with edges a-b and b-c, then node b will be returned). Note: Perl Implementation, not part of the BGL.</p>
<p>
</p>
<h2><a name="export">EXPORT</a></h2>
<p>None by default.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>The Boost Graph Library (BGL): <a href="http://www.boost.org/libs/graph/doc/">http://www.boost.org/libs/graph/doc/</a></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>David Burdick, &lt;<a href="mailto:dburdick@systemsbiology.org">dburdick@systemsbiology.org</a>&gt;

</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright 2005 by David Burdick

</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

</p>

</body>

</html>
